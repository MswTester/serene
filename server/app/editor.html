<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        body{
            background-color: #111;
            color: #fff;
            font-family: Arial, Helvetica, sans-serif;
        }
        canvas {
            width: 100vh;
            height: 100vh;
            background-color: #000;
            position: absolute;
            top: 0;
            left: 50%;
            transform: translate(-50%, 0);
            z-index: -1;
        }
        nav{
            position: absolute;
            top: 0;
            left: 50%;
            width: 80%;
            height: 50px;
            background-image: linear-gradient(to bottom, #ffffffaa, #ffffffdd 50%, #ffffff99);
            color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            transform: translate(-50%, 0);
            border-radius: 0 0 10px 10px;
        }
        button{
            width: 100px;
            height: 30px;
            border-radius: 5px;
            border: none;
            outline: none;
            background-color: #fff;
            color: #000;
            font-size: 16px;
            cursor: pointer;
        }
        button:hover{background-color: #eee;}
        button:active{background-color: #ddd;}
        input{
            width: 100px;
            height: 30px;
            border-radius: 5px;
            border: none;
            outline: none;
            padding: 0 10px;
            font-size: 16px;
        }
        input:focus{background-color: #eee;}

    </style>
</head>
<body>
    <canvas width="10000" height="10000"></canvas>
    <nav>
        <button id="new">New</button>
        <button id="open">Open</button>
        <button id="save">Save</button>
        <input type="number" name="" id="width" placeholder="width" value="10000">
        <input type="number" name="" id="height" placeholder="height" value="10000">
    </nav>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-voronoi.v1.min.js"></script>
    <script>
        const nav = document.querySelector('nav');
        const new_btn = nav.querySelector('button#new');
        const open_btn = nav.querySelector('button#open');
        const save_btn = nav.querySelector('button#save');

        const canvas = document.querySelector('canvas');
        const ctx = canvas.getContext('2d');

        let sites = []

        // console.log(d3.polygonArea([[0, 0], [0, 100], [100, 100], [100, 0]]))

        new_btn.addEventListener('click', () => {
            const width = +document.querySelector('input#width').value;
            const height = +document.querySelector('input#height').value;
            canvas.width = width || 10000;
            canvas.height = height || 10000;
            let polygons = [];
            sites = [];

            const config = {
                centerForestRange: 100,
                spaceCount: 60,
                spaceRange: 0.06,
                spaceRadius: 10,
                oceanCount: 20,
                oceanRadius: 160,
                oceanRange: [0.76, 0.8],
                oceanDeepCount:20,
                oceanDeepRadius: 140,
                oceanDeepRange: [0.86, 0.9],
                hellCount: 25,
                hellRadius: 140,
                hellRange: [0.8, 0.9],
                hellLavaCount: 20,
                hellLavaRadius: 140,
                hellLavaRange: [0.8, 0.9],
                outerBiomeCount: 10,
                outerBiomeRadius: 6,
                outerBiomeRange: [0.44, 0.6],
                innerBiomeCount: 7,
                innerBiomeRadius: 6,
                innerBiomeRange: [0.2, 0.3],
            }
            const mc = Math.floor(Math.min(canvas.width, canvas.height) / 2);

            pushToSites(makeSite(0, config.centerForestRange, 0, 360, 1, false), '#6F6', 'forest')
            const sr = (config.spaceRadius/2)
            for(let i = 0; i < config.spaceCount; i++){
                const angle = 360/config.spaceCount * i;
                pushToSites(makeSite((1-config.spaceRange)*mc, 1*mc, angle-sr, angle+sr, 1, false), '#003', 'space')
            }

            const endAngle = randInt(0, 360);

            const or = (config.oceanRadius/2)
            const odr = (config.oceanDeepRadius/2)
            // ocean
            pushToSites(makeSite(config.oceanDeepRange[0]*mc, config.oceanDeepRange[1]*mc, endAngle-odr, endAngle+odr, config.oceanDeepCount, true), '#00A', 'ocean_deep')
            pushToSites(makeSite(config.oceanRange[0]*mc, config.oceanRange[1]*mc, endAngle-or, endAngle+or, config.oceanCount, true), '#00F', 'ocean')

            const hr = (config.hellRadius/2)
            const hlr = (config.hellLavaRadius/2)
            // hell
            pushToSites(makeSite(config.hellRange[0]*mc, config.hellRange[1]*mc, endAngle+180-hr, endAngle+180+hr, config.hellCount, true), '#D00', 'hell')
            pushToSites(makeSite(config.hellLavaRange[0]*mc, config.hellLavaRange[1]*mc, endAngle+180-hlr, endAngle+180+hlr, config.hellLavaCount, true), '#F00', 'hell_lava')
            
            // outer 바이옴 생성
            makeSite(2200, 3000, 0, 360, 10, true, 6).forEach((pos, i) => {
                if(i % 3 == 0){
                    pushToSites(makeSite(0.1*mc, 0.12*mc, 0, 360, 10, true, 3, pos[0], pos[1]), '#3C3', 'jungle');
                    pushToSites(makeSite(0, 0.04*mc, 0, 360, 3, true, 2, pos[0], pos[1]), '#3A3', 'jungle_deep');
                    pushToSites(makeSite(0.06*mc, 0.08*mc, 0, 360, 3, true, 2, pos[0], pos[1]), '#069', 'jungle_river');
                } else if(i % 3 == 1){
                    pushToSites(makeSite(0.11*mc, 0.12*mc, 0, 360, 10, true, 3, pos[0], pos[1]), '#080', 'swamp');
                    pushToSites(makeSite(0.02*mc, 0.1*mc, 0, 360, 3, true, 3, pos[0], pos[1]), '#099', 'swamp_water');
                    pushToSites(makeSite(0.08*mc, 0.1*mc, 0, 360, 8, true, 2, pos[0], pos[1]), '#963', 'swamp_mud');
                } else if(i % 3 == 2){
                    pushToSites(makeSite(0.1*mc, 0.11*mc, 0, 360, 5, true, 3, pos[0], pos[1]), '#6F6', 'forest');
                    pushToSites(makeSite(0.04*mc, 0.08*mc, 0, 360, 3, true, 3, pos[0], pos[1]), '#6CF', 'forest_deep');
                    pushToSites(makeSite(0.02*mc, 0.06*mc, 0, 360, 3, true, 3, pos[0], pos[1]), '#3A5', 'forest_river');
                }
            })

            // inner 바이옴 생성
            makeSite(1000, 1500, 0, 360, 7, true, 6).forEach((pos, i) => {
                if(i % 4 == 0){
                    pushToSites(makeSite(350, 450, 0, 360, 10, true, 3, pos[0], pos[1]), '#777', 'cave');
                    pushToSites(makeSite(0, 200, 0, 360, 3, true, 2, pos[0], pos[1]), '#444', 'cave_deep');
                    pushToSites(makeSite(200, 300, 0, 360, 3, true, 2, pos[0], pos[1]), '#222', 'cave_dark');
                } else if(i % 4 == 1){
                    pushToSites(makeSite(300, 400, 0, 360, 6, true, 3, pos[0], pos[1]), '#CFF', 'snow');
                    pushToSites(makeSite(200, 400, 0, 360, 3, true, 3, pos[0], pos[1]), '#ADF', 'snow_ice');
                    pushToSites(makeSite(100, 200, 0, 360, 3, true, 3, pos[0], pos[1]), '#6DF', 'snow_lake');
                } else if(i % 4 == 2 || i % 4 == 3){
                    pushToSites(makeSite(300, 500, 0, 360, 6, true, 3, pos[0], pos[1]), '#FC6', 'desert');
                    pushToSites(makeSite(200, 500, 0, 360, 3, true, 3, pos[0], pos[1]), '#FA6', 'desert_sandstone');
                    pushToSites(makeSite(0, 120, 0, 360, 2, true, 2, pos[0], pos[1]), '#3CC', 'desert_oasis');
                }
            })

            const voronoi = d3.voronoi().extent([[0, 0], [canvas.width, canvas.height]]);

            const diagram = voronoi(sites.map(site => [site.x, site.y]));

            diagram.polygons().forEach((polygon, i) => {
                polygon = polygon.map(vertex => [Math.round(vertex[0]), Math.round(vertex[1])]);
                polygons.push(polygon);
                // 셀의 점을 찾아서 색을 가져옴
                const site = sites[i];
                
                // 셀의 경계선들을 그림
                ctx.beginPath();
                ctx.moveTo(polygon[0][0], polygon[0][1]);
                polygon.forEach(vertex => {
                    ctx.lineTo(vertex[0], vertex[1]);
                });
                ctx.closePath();

                // 셀을 해당 색으로 채움
                ctx.fillStyle = site.color;
                ctx.fill();

                // 셀에 이름을 표시
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = '100px Arial';
                ctx.fillText(site.name, site.x, site.y);
            });

            console.log(JSON.stringify(polygons));
        });

        function randInt(min, max){
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function randFloat(min, max){
            return Math.random() * (max - min) + min;
        }

        function getPosByRot(x, y, distance, angle){
            const rad = angle * Math.PI / 180;
            return [x + distance * Math.cos(rad), y + distance * Math.sin(rad)]
        }

        function makeSite(minDistance, maxDistance, minAngle, maxAngle, repeat = 1, golgoru, grange = 2, cx = 5000, cy = 5000){
            let poses = []
            for(let i = 0; i < repeat; i++){
                let angle = randInt(minAngle, maxAngle);
                if(golgoru){
                    let gap = (maxAngle - minAngle) / repeat
                    angle = minAngle + gap * i + randInt(-gap / grange, gap / grange);
                }
                const distance = randInt(minDistance, maxDistance);
                const [x, y] = getPosByRot(cx, cy, distance, angle);
                poses.push([x, y]);
            }
            return poses;
        }

        function pushToSites(poses, color, name){
            for(let i = 0; i < poses.length; i++){
                const [x, y] = poses[i];
                sites.push({x, y, color, name});
            }
        }
    </script>
</body>
</html>